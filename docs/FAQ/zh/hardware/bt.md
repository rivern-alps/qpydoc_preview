# 蓝牙开发常见问题

### **经典蓝牙和低功耗蓝牙的主要区别**

经典蓝牙（BT）和低功耗蓝牙（BLE）之间存在一些主要区别，以下是它们的一些关键差异：

- 功耗：最明显的区别在于功耗。低功耗蓝牙（BLE）专为低功耗场景设计，其能耗比经典蓝牙（BT）低很多。BLE适用于需要长时间运行且电池更换不方便的设备，如健康监测设备、智能家居等。
- 数据传输速率：经典蓝牙的数据传输速率较高，可以达到1-3 Mbps，适用于音频传输、文件传输等需要较高传输速率的应用场景。而低功耗蓝牙的数据传输速率较低，最高可达1 Mbps，适用于数据传输量较小的场景。
- 传输距离：在相同条件下，经典蓝牙的传输距离通常比低功耗蓝牙略远。经典蓝牙的传输距离可达100米，而低功耗蓝牙的传输距离通常在50米左右。实际传输距离受信号功率、传输环境、设备硬件等因素影响。
- 连接时间：低功耗蓝牙的连接时间比经典蓝牙更短。BLE设备通常在几毫秒内就能建立连接，而经典蓝牙需要较长时间，通常在几秒钟内。这使得低功耗蓝牙在需要频繁建立连接的应用场景中具有优势。
- 应用场景：由于上述差异，两种蓝牙技术在实际应用中有明显的区别。经典蓝牙适用于音频设备、汽车通讯、文件传输等场景，而低功耗蓝牙则广泛应用于穿戴设备、物联网设备、健康监测等低功耗场景。
- 兼容性：经典蓝牙和低功耗蓝牙之间的兼容性有限。虽然许多现代蓝牙设备都支持双模（即同时支持经典蓝牙和低功耗蓝牙），但两种技术在传输协议、硬件需求等方面存在差异，因此并非所有设备都能相互兼容。

### **BT传输速率最高可以达到多少？**

经典蓝牙（BT）的传输速率随着蓝牙版本的升级而提高。以下是蓝牙不同版本的最高传输速率：

- 蓝牙1.x：最高传输速率为1 Mbps。
- 蓝牙2.x + EDR（Enhanced Data Rate）：最高传输速率为3 Mbps。
- 蓝牙3.0 + HS（High Speed）：通过与802.11 Wi-Fi协议结合，理论最高传输速率可达24 Mbps。
- 蓝牙4.x：最高传输速率回归到3 Mbps，主要是因为蓝牙4.x引入了低功耗蓝牙技术（BLE）。
- 蓝牙5.x：最高传输速率为2 Mbps，但在长距离传输模式下速率会降低至500 kbps以提高传输范围。

需要注意的是，这些传输速率为理论最大值，在实际应用中可能受到设备硬件、距离、环境干扰等因素的影响，实际传输速率可能低于理论值。

### **BLE的最大传输速率是多少**

低功耗蓝牙（BLE, Bluetooth Low Energy）的最大传输速率随着蓝牙版本的升级而提高。对于BLE来说，以下是不同版本的理论最高传输速率：

- 蓝牙4.x：BLE在蓝牙4.x中首次引入，最高传输速率约为1 Mbps。
- 蓝牙5.x：在蓝牙5.x中，最高传输速率提升至2 Mbps。

需要注意的是，这些传输速率为理论最大值，在实际应用中可能受到设备硬件、距离、环境干扰等因素的影响，实际传输速率可能低于理论值。同时，在使用低功耗蓝牙时，通常更关注的是其低能耗特性，而非传输速率。

> 蓝牙4.x技术包括了经典蓝牙和低功耗蓝牙（BLE）两种模式。在经典蓝牙模式下，蓝牙4.x的最高传输速率是3 Mbps。而在低功耗蓝牙（BLE）模式下，蓝牙4.x的最高传输速率约为1 Mbps。
所以，在上面描述中，3 Mbps的数据是针对蓝牙4.x的经典蓝牙模式，而1 Mbps的数据是针对蓝牙4.x的低功耗蓝牙（BLE）模式。

### **蓝牙的服务器和客户端指的是什么？**

服务器（Server）和客户端（Client）指的是设备在通信过程中的角色。服务器负责存储和提供数据，而客户端则负责连接到服务器并请求访问其数据。在蓝牙通信中，服务器和客户端的角色是可以互相切换的。比如在BLE中，设备可以作为GATT服务器来提供数据，也可以作为GATT客户端来访问其他设备的数据服务。

### **蓝牙的主机和从机指的是什么？**

主机（Master）和从机（Slave）指的是设备在连接过程中的角色。主机通常负责发起连接请求、管理连接参数并维护设备的连接状态。而从机则是被连接的设备，负责响应主机的请求。在蓝牙通信中，主机和从机的角色可以在不同连接过程中互相切换。

> 在蓝牙通信中，服务器/客户端与主机/从机是两个相互独立的概念，它们并没有直接的对应关系。具体的主从关系以及服务器和客户端关系，取决于设备间的连接和通信需求以及使用的是BT还是BLE。

### **蓝牙的CCID**

在BLE（Bluetooth Low Energy）服务器中，UUID为0x2902的特征描述符是Client Characteristic Configuration Descriptor（CCCD），它用于管理特征值的通知和指示功能。当需要向客户端设备发送特征值的实时更新（例如，传感器数据的变化）时，可以使用通知（Notifications）和指示（Indications）这两种机制。

为了支持这些功能，需要在对应的特征上添加UUID为0x2902的特征描述符。

以下情况下需要在BLE服务器中添加UUID为0x2902的特征描述符：

- 当需要向客户端发送特征值的实时更新时，例如：环境传感器读数或设备状态变化。
- 当特征需要支持通知（Notifications）或指示（Indications）功能时。通知是一种无需客户端确认的、低延迟的数据更新机制，而指示则需要客户端的确认，以确保数据传输的可靠性。

在实践中，为特征添加UUID为0x2902的特征描述符后，客户端可以通过写入该描述符来启用或禁用特征的通知或指示功能。例如，客户端可以写入0x0001来启用通知，写入0x0002来启用指示，或写入0x0000来禁用这两种功能。

需要注意的是，并非所有特征都需要支持通知和指示功能。只有在需要实时更新特征值的情况下，才需要为特征添加UUID为0x2902的描述符。

### **BLE的public addr、random addr有什么区别？**

在BLE（Bluetooth Low Energy）中，设备地址用于唯一标识一个蓝牙设备。设备地址有两种类型：Public Address（公共地址）和Random Address（随机地址）。这两种地址类型的主要区别在于地址来源、可更改性和隐私保护方面。

**1. Public Address（公共地址）：**

公共地址是一个设备的永久地址，由IEEE注册机构（如蓝牙SIG）分配给设备制造商。这种地址具有全球唯一性，用于唯一地标识设备。公共地址通常在设备生产阶段被写入设备的硬件中，并且在设备的整个生命周期内保持不变。公共地址的前24位（OUI）由IEEE分配给制造商，而后24位由制造商分配给设备。

**2. Random Address（随机地址）：**

随机地址是设备在使用过程中动态生成的地址。它可以根据需要更改，提供了一定程度的隐私保护。随机地址分为三种子类型：

- 静态随机地址（Static Random Address）：在设备启动或复位时生成的随机地址，可在设备关机或复位后保持不变。这种地址具有一定程度的稳定性和隐私保护。
- 私有可解析随机地址（Private Resolvable Random Address）：这种随机地址可由其他已配对设备解析，但对未配对设备来说是随机的。私有可解析地址在设备连接过程中定期更改，提供了较高程度的隐私保护。
- 私有不可解析随机地址（Private Non-Resolvable Random Address）：这种随机地址对所有设备都是随机的，无法解析。私有不可解析地址提供了最高程度的隐私保护，但可能导致设备在断开连接后无法重新建立连接。

总之，Public Address和Random Address的主要区别在于：
- Public Address是永久且全球唯一的，由设备制造商分配；而Random Address是动态生成的，可以在设备使用过程中更改。
- Public Address在设备生命周期内保持不变；而Random Address可以根据需要更改，提供不同程度的隐私保护。

### **客户使用set_pa()接口后蓝牙通话无声音的解决方案**

**问题描述：**

客户设备，在没有使用audio.set_pa()接口时，蓝牙通话是正常的，有声音输出，但是使用了audio.set_pa()后，虽然蓝牙音乐播放以及本地音频播放都是有声音的，但是蓝牙通话却没有声音了；并且如果客户直接使用GPIO来使能PA控制引脚，蓝牙通话也有声音。

**问题分析：**

客户只使用了一个喇叭通道，并且在该通道上外接了一个PA；蓝牙来电时，用户在应用代码中将通道切换到了喇叭通道；结合用户问题描述，基本确定了是因为外置PA被关闭了，导致蓝牙通话无声音；

那为什么蓝牙音乐和本地音频播放都是正常的？这是因为展锐平台的set_pa功能，只支持音频播放，也就是说蓝牙音乐和本地音频播放，实际对于模组来说，最后都是调用audio相关的播放接口，只有

这个处理路径才能触发设置pa的回调，在播放开始和结束时分别打开和关闭pa，而蓝牙通话走的完全是另一个处理，也不会调用audio相关播放接口，是触发不了pa设置回调的。

用户这里其实有两种场景：

**场景1：用户调用了audio.set_pa()，但是没有进行蓝牙音乐播放，此时蓝牙通话无声音。**

这是因为，展锐的audio.set_pa()其实就是个pa控制引脚的初始化接口，真正控制pa的是在回调中进行的，当用户调用了audio.set_pa()后，对外置pa控制引脚进行了初始化，默认设置为低电平，相当于

把pa给关了，而蓝牙通话又无法触发pa控制回调，所以没有声音输出；

**场景2：用户调用了audio.set_pa()，然后进行蓝牙音乐播放，此时蓝牙音乐播放正常，然后打电话给与设备建立蓝牙连接的手机，接听后蓝牙通话无声音。**

这种场景没有声音是因为，手机端在播放音乐时，如果来电了，手机会先暂停音乐，模组收到暂停命令后，模组端也会停止播放，此时会触发pa设置回调把pa关闭，所以蓝牙通话没声音了；

上面两种场景，本质上都是pa被关闭了，而蓝牙通话本身又无法控制pa导致。

**解决方案：**

模组端，在收到蓝牙通话振铃事件时，把pa打开，然后在收到电话挂断事件时，再把pa关闭。总结起来，控制pa有一个原则，当前谁用对应通道，就由谁打开对应通道接的pa。
